import re
from gcline import GCLine
from util import listsplit

class GCodeException(Exception):
	def __init__(self, obj, message):
		self.obj = obj
		self.message = message

"""Each parser should have a detect() and a parse(). parse() returns (preamble layer, layer list)"""

#PrusaSlicer: has header comment "generated by PrusaSlicer", has
# "BEFORE_LAYER_CHANGE" and "AFTER_LAYER_CHANGE" comments,
# although these are configured per-printer in .ini files. Looks
# like new layers start at "BEFORE_LAYER_CHANGE".
#Simplify3D: has header comment "generated by Simplify3D", has
# comments "layer N" where N is a number.
#Slic3r 1.3: has header comment "generated by Slic3r", no comments
# to denote layer changes
#Cura 15: has footer comment "CURA_PROFILE_STRING", has comments
# "LAYER:N" where N is a number.
#Cura 4.6: has header comment "Generated with Cura_SteamEngine",
# has comment "LAYER:N" where N is a number.
#
#Cura 4.12: has header comment "Generated with Cura_SteamEngine",
# has comment "LAYER:N" where N is a number; in each layer, has comments
# for different types of feature:
#   ;MESH:10x10x10 cube.stl
#   ;TYPE:WALL-INNER
#   ;TYPE:WALL-OUTER
#   ;TYPE:SKIN
#   ;MESH:NONMESH
#   ;TYPE:SKIRT

__name__ = "cura4"

def detect(lines):
	return any('Cura_SteamEngine' in l for l in lines[:20])


#Convention is that preamble "layer" is -1, first print layer is 0
def parse(gcobj):
	"""Parse Cura4 Gcode into layers using the ;LAYER:N comment line."""
	layer_class = gcobj.layer_class
	#glines = [GCLine(l, lineno=n+1) for n,l in enumerate(gcobj.filelines)]
	glines = []
	last_extrude = 0
	ext_mode = 'relative'
	for i,l in enumerate(gcobj.filelines):
		line = GCLine(l, lineno=i+1)
		if line.code == 'M82': ext_mode = 'absolute'
		if line.code == 'M83': ext_mode = 'relative'
		if 'E' in line.args:
			if ext_mode == 'absolute':
				if line.code == 'G92':
					last_extrude = line.args['E']
				elif line.code in ['G0', 'G1']:
					line.relative_extrude = line.args['E'] - last_extrude
					last_extrude = line.args['E']
			else:
				line.relative_extrude = line.args['E']
		glines.append(line)

	gcobj.lines = glines.copy()

	#Extract the preamble and postamble
	preamble, glines = listsplit(glines, lambda l: l.line.startswith(';LAYER:0'),
			maxsplit=1, keepsep='>')
	postamble, glines = listsplit(reversed(glines), lambda l: l.line.startswith(';TIME_ELAPSED'),
			maxsplit=1, keepsep='>')
	postamble.reverse()
	glines.reverse()

	#Split on lines containing 'Z' to separate layers, since the ';LAYER' comment
	# happens after a Z move.
	layergroups = listsplit(glines, lambda l: 'Z' in l.line, keepsep='>')

	#The first group will probably be a bogus layer due to an early Z, so add it
	# to the preamble
	preamble.extend(layergroups.pop(0))

	layergroups = [layer_class(g) for g in layergroups]

	#Manually set number of layer 0 because the ';LAYER' comment is now attached
	# to the preamble
	layergroups[0].layernum = 0

	#Add layer height to each layer if we can find the layer height from the preamble comment
	m = next(filter(None, [re.search('Layer height:\s+(\d+\.\d+)', l.line, re.I)
		for l in preamble]))
	if m:
		layer_height = float(m.group(1))
		for layer in layergroups:
			layer.layer_height = layer_height

	#Find the layer number in each group of lines
	for i,layer in enumerate(layergroups[1:]):
		try:
			layer.layernum = int(next(filter(
				lambda l: l.line.startswith(';LAYER'), layer.lines)).line.split(':')[1])
		except (StopIteration, AttributeError) as e:
			raise GCodeException(layer,
					f"Couldn't find ';LAYER' comment in layer {i+1} (lines {layer.lines.first().lineno} - {layer.lines.last().lineno})") from e

	#For each layer, find the starting absolute extrusion value (the last
	# extrusion in the previous layer)
	for i,layer in enumerate(layergroups[1:]):
		try:
			last_extrude_line = next(filter(GCLine.is_extrude, reversed(layer.lines)))
		except:
			layer.last_extrude = None
		else:
			layer.last_extrude = last_extrude_line.args['E']

	postamble = layer_class(postamble, layernum='postamble')
	preamble  = layer_class(preamble, layernum='preamble')
	preamble.info = {}
	for line in preamble.lines:
		if line.line.startswith(';') and ':' in line.line:
			key, val = line.line[1:].split(':', maxsplit=1)
			preamble.info[key] = val

	gcobj.preamble  = preamble
	gcobj.layers    = layergroups
	gcobj.postamble = postamble


def parse_3mf(filename):
	"""Usage:
		1. Export thread + object as a 3MF file from Fusion.
		2. Import Fusion 3MF file into Cura. Select thread pipe + object and Group.
		3. Position where you want it.
		4. Save as Cura project, then use that file with this function.

		Returns the transform of the grouped object - assumes thread and object
		have not moved relative to each other.

		The 3MF file seems to use the front-left corner of the bed as origin, which
		is what we want. This is even though the UI uses the center of the bed as
		origin. The 0,0 point of the object in the 3MF file seems to be at the
		center of the bounding box.

		We can test this by setting the xy transform for the object to
		(bed_width/2 - obj_width/2, bed_height/2 - height/2), which should put the
		bounding box in the UI at the front-left corner, and the transform in the
		3MF file then is equal to (roughly?) half the bounding box.
	"""
	#TODO: need to parse the 3MF to find the bounding box of the joined shapes,
	# then subtract half the z bounding box from the z transform, since it works
	# by the center of the object.
	import zipfile
	import xml.etree.ElementTree as ET
	import numpy as np
	namespace = {
			"3mf": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02",
			"m"  : "http://schemas.microsoft.com/3dmanufacturing/material/2015/02"
	}

	archive = zipfile.ZipFile(filename, "r")
	root = ET.parse(archive.open("3D/3dmodel.model"))
	findall = lambda s:root.findall(s, namespace)

	try:
		creator = root.find("./3mf:metadata[@name='Application']", namespace).text
		if 'Cura' not in creator:
			raise ValueError("Not created by Cura")
	except (AttributeError, ValueError):
		print("Not a Cura 3MF file")
		return

	mins = [float( 'inf')]*3
	maxs = [float('-inf')]*3
	for vertex in findall("./3mf:resources/3mf:object/3mf:mesh/3mf:vertices/3mf:vertex"):
		vals = map(float, [vertex.get(a) for a in 'xyz'])
		mins = [min(old, new) for old, new in zip(mins, vals)]
		maxs = [max(old, new) for old, new in zip(maxs, vals)]


	try:
		return np.fromstring(
			root.find("./3mf:build/3mf:item", namespace).get('transform'),
			dtype=float, sep=' ')[-3:]
		# objs = {obj.get('id'):obj for obj in findall("./3mf:resources/3mf:object")}
		# trans_objs = (findall("./3mf:resources/3mf:object/3mf:components//") or
		# 							findall("./3mf:build/3mf:item"))
		# transforms = [
		# 	( objs[i.get('objectid')],
		# 		np.fromstring(i.get('transform'), dtype=float, sep=' ')[-3:]
		# 	) for i in trans_objs]
	except Exception as e:
		print(e)
		print("Probably means no transforms could be found; here's findall:")
		return findall
