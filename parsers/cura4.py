from gcline import Line
from gclayer import Layer
from util import listsplit

class GCodeException(Exception):
	def __init__(self, obj, message):
		self.obj = obj
		self.message = message

"""Each parser should have a detect() and a parse(). parse() returns (preamble layer, layer list)"""

#PrusaSlicer: has header comment "generated by PrusaSlicer", has
# "BEFORE_LAYER_CHANGE" and "AFTER_LAYER_CHANGE" comments,
# although these are configured per-printer in .ini files. Looks
# like new layers start at "BEFORE_LAYER_CHANGE".
#Simplify3D: has header comment "generated by Simplify3D", has
# comments "layer N" where N is a number.
#Slic3r 1.3: has header comment "generated by Slic3r", no comments
# to denote layer changes
#Cura 15: has footer comment "CURA_PROFILE_STRING", has comments
# "LAYER:N" where N is a number.
#Cura 4.6: has header comment "Generated with Cura_SteamEngine",
# has comment "LAYER:N" where N is a number.
#
#Cura 4.12: has header comment "Generated with Cura_SteamEngine",
# has comment "LAYER:N" where N is a number; in each layer, has comments
# for different types of feature:
#   ;MESH:10x10x10 cube.stl
#   ;TYPE:WALL-INNER
#   ;TYPE:WALL-OUTER
#   ;TYPE:SKIN
#   ;MESH:NONMESH
#   ;TYPE:SKIRT

__name__ = "Cura4"

class Cura4Layer(Layer):
	"""A Layer, but using the comments in the Cura gcode to add additional useful
	members:
		Layer.meshes -> a list of sub-meshes to be found in this layer
			each containing
				.features -> a dict of lines by feature type

	Cura Gcode as of 4.12.1 has the same pattern every layer except layer 0.
	"""
	def __init__(self, lines=[], layernum=None):
		if layernum > 0:
			self.parts = listsplit(lines,
					lambda l: l.line.startswith(';TYPE:') or l.line.startswith(';MESH'),
					keepsep='>', minsize=2)



def detect(lines):
	return any('Cura_SteamEngine' in l for l in lines[:20])


#Convention is that preamble "layer" is -1, first print layer is 0
def parse(lines, layer_class=Layer):
	"""Parse Cura4 Gcode into layers using the ;LAYER:N comment line."""
	glines = [Line(l, lineno=n+1) for n,l in enumerate(lines)]

	#Extract the preamble and postamble
	preamble, glines = listsplit(glines, lambda l: l.line.startswith(';LAYER:0'),
			maxsplit=1, keepsep='>')
	postamble, glines = listsplit(reversed(glines), lambda l: l.line.startswith(';TIME_ELAPSED'),
			maxsplit=1, keepsep='>')
	postamble.reverse()
	glines.reverse()

	#Split on lines containing 'Z' to separate layers, since the ';LAYER' comment
	# happens after a Z move.
	layergroups = listsplit(glines, lambda l: 'Z' in l.line, keepsep='>')

	#The first group will probably be a bogus layer due to an early Z, so add it
	# to the preamble
	preamble.extend(layergroups.pop(0))

	layergroups = [layer_class(g) for g in layergroups]

	#Manually set number of layer 0 because the ';LAYER' comment is now attached
	# to the preamble
	layergroups[0].layernum = 0

	#Find the layer number in each group of lines
	for i,layer in enumerate(layergroups[1:]):
		try:
			layer.layernum = int(next(filter(
				lambda l: l.line.startswith(';LAYER'), layer.lines)).line.split(':')[1])
		except (StopIteration, AttributeError) as e:
			raise GCodeException(layer,
					f"Couldn't find ';LAYER' comment in layer {i+1}") from e

	#WARNING: not returning postamble!
	postamble = layer_class(postamble, layernum='postamble')
	preamble  = layer_class(preamble, layernum='preamble')
	preamble.info = {}
	for line in preamble.lines:
		if line.line.startswith(';') and ':' in line.line:
			key, val = line.line[1:].split(':', maxsplit=1)
			preamble.info[key] = val

	return preamble, layergroups
